Short answer:
B=[194, 291, 1, 486, 2, 196, 293, 584, 197, 101, 586, 5, 102, 781, 6, 394, 976, 492, 493, 784, 106, 591, 10, 204, 689, 399, 690, 884, 206, 400, 207, 401, 498, 789, 111, 208, 305, 112, 500, 791, 888, 113, 501, 695, 503, 891, 116, 989, 505, 699, 893, 894, 22, 119, 313, 604, 895, 217, 702, 993, 121, 218, 800, 25, 26, 414, 125, 29, 514, 805, 999, 418, 31, 128, 613, 807, 323, 227, 712, 325, 616, 810, 132, 36, 424, 961, 89, 186, 672, 866, 330, 287, 384, 191, 676, 192, 581]
which sums to 41710, which is 430*97.


Bonus solution is [900, 1, 151, 301, 152, 752, 902, 4, 304, 604, 455, 755, 905, 6, 456, 606, 906, 7, 308, 758, 908, 9, 609, 909, 610, 760, 311, 461, 611, 761, 612, 762, 313, 463, 613, 164, 464, 764, 914, 465, 615, 915, 166, 466, 916, 317, 618, 768, 169, 320, 620, 770, 921, 323, 623, 923, 174, 625, 26, 926, 177, 478, 778, 179, 779, 180, 630, 930, 31, 631, 781, 482, 932, 483, 933, 34, 184, 784, 934, 186, 337, 637, 787, 339, 190, 490, 790, 940, 491, 641, 642, 792, 193, 643, 344, 944, 195, 495, 795, 945, 196, 796, 47, 947, 798, 948, 49, 199, 799, 200, 350, 501, 801, 951, 53, 203, 54, 205, 805, 806, 507, 359, 60, 960, 61, 361, 511, 811, 212, 662, 290, 590, 740, 141, 291, 592, 892, 143, 68, 744, 595, 895, 146, 897, 148, 298, 598, 149, 299, 599]
which sums to 77400, which is 516 * 150.

Long answer:
Relatively easy one, totally brute-force-able, even the bonus.
My brute force solution was to generate all 2^n possible n-length binary arrays, and iterate through those to create candidate B ararys. Then a simple filter for solutions based on congruence to 0 mod n.
Creating B from the n-length binary array was to select the first element in the A pair if the binary element was false and the second element otherwise.

val A = IndexedSeq(194, 236, 291, 430,...
val twon = A.size                                //> twon  : Int = 194
val n = twon / 2   // 97


// Select the elements from A to create B. The elements are selected based on the n-length Boolean array.
val Bcandidates = allBinarySequencesFromBigInt(n).map{ bSequence =>
  (bSequence.zipWithIndex.map{ case(bool, index) => if (bool) A(2*index+1) else A(2*index) }, bSequence)
 }                                                //> Bcandidates  : Iterator[(IndexedSeq[Int], IndexedSeq[Boolean])] = non-empty

val solutions = Bcandidates.zipWithIndex.filter{ case ((bCandidates, booleans), i) =>
  //if (i %100000 == 0 ) println(Bcandidates + " sum " + bCandidates.sum + " mod " + n  + " = " + bCandidates.sum % n)
  bCandidates.sum % n == 0
 }                                                //> solutions  : Iterator[((IndexedSeq[Int], IndexedSeq[Boolean]), Int)] = non-

solutions.foreach(solution=>println(solution._1 + " at position " + solution._2))

 def allBinarySequencesFromBigInt(n: Int) : Iterator[IndexedSeq[Boolean]] = Iterator.iterate(BigInt(0))(_ + 1).takeWhile( _.toString(2).size <= n)
  .map( b => b.toString(2).reverse.padTo(n, '0').reverse // convert the BigInt to a binary String and 0-pad it to length n.
  .map( s => if (s == '0') false else true))

 // Same thing as above but without BigInts and done recursively.
 def allBinarySequenciesofLengthN(n: Int) : Iterator[IndexedSeq[Boolean]] = n match {
  case 0 => Iterator(IndexedSeq())
  case _ => for{
   h <- Iterator(false,true)
   rest <- allBinarySequenciesofLengthN(n-1)
  } yield h +: rest
 } 


Bonus solution is [900, 1, 151, 301, 152, 752, 902, 4, 304, 604, 455, 755, 905, 6, 456, 606, 906, 7, 308, 758, 908, 9, 609, 909, 610, 760, 311, 461, 611, 761, 612, 762, 313, 463, 613, 164, 464, 764, 914, 465, 615, 915, 166, 466, 916, 317, 618, 768, 169, 320, 620, 770, 921, 323, 623, 923, 174, 625, 26, 926, 177, 478, 778, 179, 779, 180, 630, 930, 31, 631, 781, 482, 932, 483, 933, 34, 184, 784, 934, 186, 337, 637, 787, 339, 190, 490, 790, 940, 491, 641, 642, 792, 193, 643, 344, 944, 195, 495, 795, 945, 196, 796, 47, 947, 798, 948, 49, 199, 799, 200, 350, 501, 801, 951, 53, 203, 54, 205, 805, 806, 507, 359, 60, 960, 61, 361, 511, 811, 212, 662, 290, 590, 740, 141, 291, 592, 892, 143, 68, 744, 595, 895, 146, 897, 148, 298, 598, 149, 299, 599]

),104652)
104652 in binary is 0b11111111011111111111


For an added challenge I calculated the number of solutions to each of the problems.
They are 1640967457544366442515945468 solutions.

and for the bonus: 16035579592615422135362088368615933413381520 solutions.

And for the example case with n=7 given in the question there are 35 solutions.

After coding up the ideas to count the number of solutions I realized there would be only minor modifications necessary to fully list out all the solutions. Of course, with such an exponentially large number of solutions it would never be practical, nevertheless, since they are generated lazily so I can "take" as many as I want at run time.

The algorithm to count the number of solutions uses dynamic programming.
Consider the first k pairs of A.

Count the number of ways to sum up to each of the n sums, given the first k pairs of A. Store this in an array of ints of length n. Letting k=0, (the base case), we have exactly 1 way to sum to 0 (via the sum of the empty set), and all other sums of n are impossible (0 cases). So our base "sumsSoFar" array is a 1 followed by n-1 zeroes.

Now consider adding another pair from A, (k+1st term).
We can choose either the first element (p1) or the second (p2).
For example, say with k terms we have 6 ways to sum to 30. And say p1 is 4. Now we know there are 6 ways to sum to 34 using k+1 terms.
Well, not quite since we have to consider p2. Say p2 is 10, and say with k terms we had 3 ways to sum to 24. p2 will generate another 3 ways to sum to 34. So in total there will now be 9 ways to sum to 34.
This method is repeated to generate two n-length vectors, one for each element of the pair. The two vectors are added element-wise to create the resulting sum vector for the k+1 case.
This is repeated until A is consumed. The result of interest is the zeroth term of the array, which represents the number of ways to sum to 0 (mod n).


 // 1 0 0 0 .... for 150 terms indicates that there's 1 way to sum to 0, and no other possibilities.
 // 0 1 0 2 .... indicates there is 1 way to sum to 1; and 2 ways to sum to 3.
 // if we have the option to add 3 (p1), say, we'd just shift that vector to the right by 3.
 // 0 0 0 0 1 0 2 ... this means that the ways to sum to 1 are now ways to sum to 4; and the 2 ways to sum to 3 are now 2 ways to sum to 6.
 // we repeat to create another vector with the other option to add (say 5)(p2)
 // 0 0 0 0 0 0 1 0 2 ...
 // And we finish by combining them, adding them element-wise. This is because all the combinations are disjoint (assuming unique elements of A, or at least
 // the two elements making that pair are distinguishable.
 val numberOfWaysToSumToIndex = A.map( _ % n).grouped(2).foldLeft(BigInt(1) +: IndexedSeq.fill(n-1)(BigInt(0))){ case (sumsSoFar, IndexedSeq(p1,p2)) =>
   (rotateBy(sumsSoFar, p1), rotateBy(sumsSoFar, p2)).zipped.map( _ + _ )
 }
 
 // Shift it by k to the right. Implement at circular array. Rotate.
 // k is guarenteed to be 0<=k<n by the caller so it's not necessary to do the mod here as well.
 def rotateBy(A: IndexedSeq[BigInt], k: Int): IndexedSeq[BigInt] = A.drop(A.size - k%A.size) ++ A.take(A.size - k%A.size)

Great!

The use of BigInts are necessary because the results grow far greater than Longs very quickly.

We can use almost the exact same pattern to generate all solutions. The large number shouldn't be a problem using Streams (or LazyLists in the newer version of Scala) since they are lazily evaluted and gargabe collected.

There are only 4 small differences
1. We are now working with an array of Streams of ways to sum to a given index (instead of just counting the number of ways). This will involve a total of nxn Streams, instead of nxn Ints as before.
2. The base case (this is tricky) is an n-length array, where the first element (corresponding to the ways to sum to 0) is a Stream of the empty List of ints. All the other n-1 elements are just the empty Stream. In the previous case, the first element was a 1, and the rest were 0.
3. The induction step is slightly more complex. To account for the addition of p1 and p2 (the new elements from A) we must prepend p1 and p2 respectively to all the previous Lists of Ints before shifting their positions in the Array. (see rotateArrayAndPrependStreamsWithInt)
4. Combining the new Streams of solutions involves concatenating the Streams ++. Previously we simply added the ints.

val generateSolutionsViaListingWaysToSumToIndex = A.grouped(2).foldLeft( Stream(List[Int]()) +: IndexedSeq.fill(n-1)(Stream()) ){ case (sumsSoFar, IndexedSeq(p1,p2)) =>
  (rotateArrayAndPrependStreamsWithInt(sumsSoFar, p1), rotateArrayAndPrependStreamsWithInt(sumsSoFar, p2)).zipped.map( _ ++ _ )
 }
 

 def rotateArrayAndPrependStreamsWithInt(A: IndexedSeq[Stream[List[Int]]], k: Int): IndexedSeq[Stream[List[Int]]] = {
  val (first, second) = A.map(_.map(k +: _)).splitAt(A.size - k%A.size)
  second ++ first
 }


Now any number of solutions can generated almost instantly.
val solutionsOfSumsEqual0ModN = generateSolutionsViaListingWaysToSumToIndex.head
solutionsOfSumsEqual0ModN.take(10000).foreach(x=>println(x.reverse))

 //> List(236, 430, 721, 819, 44, 238, 529, 45, 433, 46, 337, 725, 102, 144, 6, 
 //| 242, 533, 244, 632, 729, 536, 149, 537, 634, 150, 399, 690, 884, 206, 400, 
 //| 207, 401, 498, 789, 111, 208, 305, 112, 500, 791, 888, 113, 501, 695, 503, 
 //| 891, 116, 989, 505, 699, 893, 894, 22, 119, 313, 604, 895, 217, 702, 993, 1
 //| 21, 218, 800, 25, 26, 414, 125, 29, 514, 805, 999, 418, 31, 128, 613, 807, 
 //| 323, 227, 712, 325, 616, 810, 132, 36, 424, 522, 135, 426, 39, 233, 330, 81
 //| 5, 912, 137, 525, 41, 623)
 //| List(236, 430, 721, 819, 44, 238, 529, 45, 433, 46, 337, 5, 822, 144, 6, 24
 //| 2, 533, 244, 632, 729, 536, 149, 537, 634, 150, 399, 690, 884, 206, 400, 20
 //| 7, 401, 498, 789, 111, 208, 305, 112, 500, 791, 888, 113, 501, 695, 503, 89
 //| 1, 116, 989, 505, 699, 893, 894, 22, 119, 313, 604, 895, 217, 702, 993, 121
 //| , 218, 800, 25, 26, 414, 125, 29, 514, 805, 999, 418, 31, 128, 613, 807, 32
 //| 3, 227, 712, 325, 616, 810, 132, 36, 424, 522, 135, 426, 39, 233, 330, 815,
 //|  912, 137, 525, 41, 623)
...


Testing the size of the solutions generated this way matches for the n=7 example given, but is impractical for the main questions.
// solutionsOfSumsEqual0ModN.size


Verifying and plotting in Octave yielded some interesting sinusoid patterns, especially in the bonus question.
By reducing A mod n for the bonus question, we can see that it was generated or sorted in a paculiar way, probably to maximize the difficulty of the problem. I originally thought the trick was to match up the small values near the bigging with the large values at the end so that the pairs add up to 150.
The sum of the total number of ways to add up to all the n's from 0 to n-1 must be 2^n, which I was able to verify.
Perhaps the reason for the sinusoidal pattern is because of the similarities to computing a convolution, which is (hand-wavy) kind of related to sinusoids and the fourier domain.??? Thoughts for future work.

In any event, fun problem this month. Glad I was able to get the bonus, unlike last month.

Chris Shannon
(from Calgary Canada)



B=[194, 291, 1, 486, 2, 196, 293, 584, 197, 101, 586, 5, 102, 781, 6, 394, 976, 492, 493, 784, 106, 591, 10, 204, 689, 399, 690, 884, 206, 400, 207, 401, 498, 789, 111, 208, 305, 112, 500, 791, 888, 113, 501, 695, 503, 891, 116, 989, 505, 699, 893, 894, 22, 119, 313, 604, 895, 217, 702, 993, 121, 218, 800, 25, 26, 414, 125, 29, 514, 805, 999, 418, 31, 128, 613, 807, 323, 227, 712, 325, 616, 810, 132, 36, 424, 961, 89, 186, 672, 866, 330, 287, 384, 191, 676, 192, 581]
,4031)

mod(sum(B),length(B))
ans = 0

sumToBonus=[16035579592615422135362088368615933413381520, 16035579592615422135362088368615933413381520, 15985270281321508938363141205405236437060304, 15885133825748655684774654984832228005619296, 15736127479553090661529816684068906863740144, 15539669580396668451754788862775728173109520, 15297618936820201880097461429875678229031440, 15012248061294396380611068341628546109232144, 14686210838227938152729695919662461801115808, 14322505331422000686370781473795201212403520, 13924432531678841658308982526163416910088096, 13495551919527106295891776185875948924622544, 13039634768534986920992519592365454579510512, 12560616140397334243837740040543322365490672, 12062546523613432028947639237539048902946784, 11549544043578767530211461164850767547036496, 11025748124477694546423626910457690241949104, 10495275414332229512310922753290019931487376, 9962178696375859414496633663309304215135760, 9430409405522069066000816970412413147980384, 8903784251424145098548034370236678916301552, 8385956323098120410543905910627713704873888, 7880390918092684341693635632983989613424928, 7390346205574402189507332651715382259491376, 6918858701223018198807340308384380511391120, 6468733406095937350285745295561347952582240, 6042538344949444160738795363737421836514800, 5642603134869899021025669139021622081143920, 5271021125022156666883210313579526453530064, 4929654574940787752969867812079444969551792, 4620142283636213467667809521303147274213232, 4343909045893055914960890036687454028924848, 4102176295992764664060362885369394998857376, 3895973302655929962304273522898859761327344, 3726148301718883218380825201871555347082576, 3593378993900511770654049497170821898841808, 3498181892503857434379181501009764586826512, 3440920078164236713764189706734298932451952, 3421809002591435476761514751867343914827808, 3440920078164236713764189706734298932451952, 3498181892503857434379181501009764586826512, 3593378993900511770654049497170821898841808, 3726148301718883218380825201871555347082576, 3895973302655929962304273522898859761327344, 4102176295992764664060362885369394998857376, 4343909045893055914960890036687454028924848, 4620142283636213467667809521303147274213232, 4929654574940787752969867812079444969551792, 5271021125022156666883210313579526453530064, 5642603134869899021025669139021622081143920, 6042538344949444160738795363737421836514800, 6468733406095937350285745295561347952582240, 6918858701223018198807340308384380511391120, 7390346205574402189507332651715382259491376, 7880390918092684341693635632983989613424928, 8385956323098120410543905910627713704873888, 8903784251424145098548034370236678916301552, 9430409405522069066000816970412413147980384, 9962178696375859414496633663309304215135760, 10495275414332229512310922753290019931487376, 11025748124477694546423626910457690241949104, 11549544043578767530211461164850767547036496, 12062546523613432028947639237539048902946784, 12560616140397334243837740040543322365490672, 13039634768534986920992519592365454579510512, 13495551919527106295891776185875948924622544, 13924432531678841658308982526163416910088096, 14322505331422000686370781473795201212403520, 14686210838227938152729695919662461801115808, 15012248061294396380611068341628546109232144, 15297618936820201880097461429875678229031440, 15539669580396668451754788862775728173109520, 15736127479553090661529816684068906863740144, 15885133825748655684774654984832228005619296, 15985270281321508938363141205405236437060304, 16035579592615422135362088368615933413381520, 16035579592615422135362088368615933413381520, 15985270281321508938363141205405236437060304, 15885133825748655684774654984832228005619296, 15736127479553090661529816684068906863740144, 15539669580396668451754788862775728173109520, 15297618936820201880097461429875678229031440, 15012248061294396380611068341628546109232144, 14686210838227938152729695919662461801115808, 14322505331422000686370781473795201212403520, 13924432531678841658308982526163416910088096, 13495551919527106295891776185875948924622544, 13039634768534986920992519592365454579510512, 12560616140397334243837740040543322365490672, 12062546523613432028947639237539048902946784, 11549544043578767530211461164850767547036496, 11025748124477694546423626910457690241949104, 10495275414332229512310922753290019931487376, 9962178696375859414496633663309304215135760, 9430409405522069066000816970412413147980384, 8903784251424145098548034370236678916301552, 8385956323098120410543905910627713704873888, 7880390918092684341693635632983989613424928, 7390346205574402189507332651715382259491376, 6918858701223018198807340308384380511391120, 6468733406095937350285745295561347952582240, 6042538344949444160738795363737421836514800, 5642603134869899021025669139021622081143920, 5271021125022156666883210313579526453530064, 4929654574940787752969867812079444969551792, 4620142283636213467667809521303147274213232, 4343909045893055914960890036687454028924848, 4102176295992764664060362885369394998857376, 3895973302655929962304273522898859761327344, 3726148301718883218380825201871555347082576, 3593378993900511770654049497170821898841808, 3498181892503857434379181501009764586826512, 3440920078164236713764189706734298932451952, 3421809002591435476761514751867343914827808, 3440920078164236713764189706734298932451952, 3498181892503857434379181501009764586826512, 3593378993900511770654049497170821898841808, 3726148301718883218380825201871555347082576, 3895973302655929962304273522898859761327344, 4102176295992764664060362885369394998857376, 4343909045893055914960890036687454028924848, 4620142283636213467667809521303147274213232, 4929654574940787752969867812079444969551792, 5271021125022156666883210313579526453530064, 5642603134869899021025669139021622081143920, 6042538344949444160738795363737421836514800, 6468733406095937350285745295561347952582240, 6918858701223018198807340308384380511391120, 7390346205574402189507332651715382259491376, 7880390918092684341693635632983989613424928, 8385956323098120410543905910627713704873888, 8903784251424145098548034370236678916301552, 9430409405522069066000816970412413147980384, 9962178696375859414496633663309304215135760, 10495275414332229512310922753290019931487376, 11025748124477694546423626910457690241949104, 11549544043578767530211461164850767547036496, 12062546523613432028947639237539048902946784, 12560616140397334243837740040543322365490672, 13039634768534986920992519592365454579510512, 13495551919527106295891776185875948924622544, 13924432531678841658308982526163416910088096, 14322505331422000686370781473795201212403520, 14686210838227938152729695919662461801115808, 15012248061294396380611068341628546109232144, 15297618936820201880097461429875678229031440, 15539669580396668451754788862775728173109520, 15736127479553090661529816684068906863740144, 15885133825748655684774654984832228005619296, 15985270281321508938363141205405236437060304];

plot(log(sumToBonus ))
hold on

sumTo = [1640967457544366442515945468, 1644761884066082652007811925, 1648368743096335869245507481, 1651727584362829388429882033, 1654782114312719147642879564, 1657481139584488389609901649, 1659779425002420714447063710, 1661638451712713551648269082, 1663027062755554669353682606, 1663921985252483691940741819, 1664308220457899086219301761, 1664179295136555814512156339, 1663537370054604741470231641, 1662393203765132245687103817, 1660765972295917411307867700, 1658682947760790971504854665, 1656179041281752864052505399, 1653296217881953898893668888, 1650082793156708778243717060, 1646592623509868398304804962, 1642884203527787892913925916, 1639019685618437229910842730, 1635063838347073410706965338, 1631082960926281384271350300, 1627143772053825626194013233, 1623312291720791525936183300, 1619652734731101073881276212, 1616226434476394669994564882, 1613090815003738766527528664, 1610298428603583676248912521, 1607896075047861569714562139, 1605924017239174571066383962, 1604415306416541296885601990, 1603395228226659961037196870, 1602880878944342352190021500, 1602880878944342352190021500, 1603395228226659961037196870, 1604415306416541296885601990, 1605924017239174571066383962, 1607896075047861569714562139, 1610298428603583676248912521, 1613090815003738766527528664, 1616226434476394669994564882, 1619652734731101073881276212, 1623312291720791525936183300, 1627143772053825626194013233, 1631082960926281384271350300, 1635063838347073410706965338, 1639019685618437229910842730, 1642884203527787892913925916, 1646592623509868398304804962, 1650082793156708778243717060, 1653296217881953898893668888, 1656179041281752864052505399, 1658682947760790971504854665, 1660765972295917411307867700, 1662393203765132245687103817, 1663537370054604741470231641, 1664179295136555814512156339, 1664308220457899086219301761, 1663921985252483691940741819, 1663027062755554669353682606, 1661638451712713551648269082, 1659779425002420714447063710, 1657481139584488389609901649, 1654782114312719147642879564, 1651727584362829388429882033, 1648368743096335869245507481, 1644761884066082652007811925, 1640967457544366442515945468, 1637049057385403252378042423, 1633072355203151424136313945, 1629103999726734947704330317, 1625210499781093761222000787, 1621457109612969029807300568, 1617906735244776356266585785, 1614618880184609570401154016, 1611648648162900838606789655, 1609045819608494962458416715, 1606854017342892083236129350, 1605109975474204680597037332, 1603842923744789961580045649, 1603074097649552406138959371, 1602816382535981168987234594, 1603074097649552406138959371, 1603842923744789961580045649, 1605109975474204680597037332, 1606854017342892083236129350, 1609045819608494962458416715, 1611648648162900838606789655, 1614618880184609570401154016, 1617906735244776356266585785, 1621457109612969029807300568, 1625210499781093761222000787, 1629103999726734947704330317, 1633072355203151424136313945, 1637049057385403252378042423];
plot(log(sumTo))


