Search gmail for euler totient.

Find euler totient expression from that basic program that elavuates it from the prime decomposition of n.

We can create n starting from the prime decomposition!


Euler Totient(n) = 3,031....
natural numbers that are smaller than it are relatively prime to it.
factor 3,031,634,148,236,289,733,373,855,928,919,180,891,127,808
3031634148236289733373855928919180891127808
2^18×3^3×7^2×11×13×47×3169×8887×66643×72161×2495839×3847619 (32 prime factors, 12 distinct)
https://www.wolframalpha.com/input/?i=factor+3%2C031%2C634%2C148%2C236%2C289%2C733%2C373%2C855%2C928%2C919%2C180%2C891%2C127%2C808
phi(p^e) = (p - 1) * p^(e-1)
n=p^e
Consider all the multiples of p: 1,p,2p,3p...n. There are n/p of them. Since n is a multiple of p, gcd(n, kp) == p != 1. So all the rest are coprime: n - n/p.
n-n/p = p^e - p^e /p = p^e - p^(e-1) = p*p^(e-1) - p^(e-1) = (p-1)*p^(e-1)
When phi(n) = m
and n = p2^e2*p3^e3*p5^e5...
phi(n) = (p2-1)*p2^(e2-1) * (p3-1)*p3^(e3-1) * (p5-1)*p5^(e5-1) * ...
=m
Since m has 2^18, does that mean there's 18 terms (due to the pi-1 being even)... but there's only 12 ps.
http://www.numbertheory.org/php/carmichael.html
https://magma.maths.usyd.edu.au/magma/handbook/text/165
Magma FactoredEulerPhiInverse(n)

phi(m) = m1 = 711074604856637023865256874613665274265600
124857181535633965275735199916627066880000
24225619894874245948715357303734272000000
5529217548833632444936156946104320000000
1394110647407292870823319728816128000000

https://hal.archives-ouvertes.fr/file/index/docid/423598/filename/tot.pdf
http://www.numbertheory.org/calc/krm_calc.html#carmichael
This solves φ(x) = n. See BCMath description. 
There are 7293 primes p with p-1 dividing n. So we stop if we find two solutions.
16848708591794295073020268383569024055179130
16848592165121351464227091751702269213660890 are two solutions






Aliquot sum(n) = 12,142....
find a number whose sum of divisors (excluding itself) is
factor 12,142,680,281,284,711,468,101,282,998,309,016,699,980,172
2^2×3×61×138977×340533901×350509822519285183744989673 (7 prime factors, 6 distinct)
https://www.wolframalpha.com/input/?i=factor+12%2C142%2C680%2C281%2C284%2C711%2C468%2C101%2C282%2C998%2C309%2C016%2C699%2C980%2C172


12,142.../ 3,031... = 4.005325078010796398161726082591613490820572843433160384278...


12142680281284711468101282998309016699980172



Hmmm, modified the source of calc (primes1.c) to output all solutions to instead of just 2. It still only gave 2 solutions, which I guess is super common for inverse totient.
carmichael(3031634148236289733373855928919180891127808), and it only gives those two solutions.
Plugging them into wolfram
aliquot sum of 16848708591794295073020268383569024055179130
41108265904814468458047127650517880741103750

aliquot sum of 16848592165121351464227091751702269213660890
41107581357225605166293275770993455467800870

But at least wolfram varied that they are solutions.
Maybe there's more?
Yes, there is, took out the hard coded values of 100 limit, then changed the max_array_size from 2^16 to 2^32.
Now it's barfing out solutions.
16848708591794295073020268383569024055179130 16848592165121351464227091751702269213660890 16848594038217565877618663630575346953364970 16848589155401581075171840198559755562871810 16848589155380950481542630931487567533115810 16848589155376257488437938733526051464987890 16661940890579198816768932949840433024254370 16636679293384285567304935275212569107143970 16636657216319554878012845280607488978919170 16589440047421368898176691792003429121883330 16589425666484344119630714216888751030574730 16589425665856394656995889638480391960976730 16589425665804953145500281636370611541942130 16589327256599270390342774447282369497654770 16589319562010353291383234329521981909652730 16589312875104725693152576281805508822040570 16555928603578978260210020935299123119642370 16555928592354617770392247517269301431993770 16555928592326145024450619025392250890328970 16555822702723104247154820367305020402492970 16555813877859254427327857172013261491958110 16555813877858470753667689057060165673362110 16555813877858393580875664463381331093099370 16545943888342469737874926466460120247985130 16545829243109981779230590981015819254411890 16545346115308372950846349691192523543977910 16545346114910834000656280040503090845439910 16544333451498722234804411605398402767733330 16544218817387501930923482409313938969649010 16534073139509438051579612228864617121567310 16530839906356426923351150312724701921909570 16530808740104224225980768436435235737474890 16530808545134043021953118064407163637977770 16530807935312734413986721888285311423559510 16530806397052961138170539870816424314463770 16530805837944747925691721803764786685037390 16530805787206886336983155301518680515077510 16530805787128022612555192909161991065395390 16530805787126329489792169019505961556912390 16530791561682112707111415346277087209231610 16530724349791397757543912891784522346885970 16530714441922091561309196121757510900759970 16530693930635596424983839251281471621091070 16530693445773880023569098496177268455594910 16530693395952624933857833148967242569502610 16530693394957502470040....
Now I need to feed that into aliquot...


https://rosettacode.org/wiki/Proper_divisors#Scala
import scala.annotation.tailrec
 
def factorize(x: BigInt): List[BigInt] = {
  @tailrec
  def foo(x: BigInt, a: BigInt = 2, list: List[BigInt] = Nil): List[BigInt] = a * a > x match {
    case false if x % a == 0 => foo(x / a, a, a :: list)
    case false => foo(x, a + 1, list)
    case true => x :: list
  }
 
  foo(x)
}
 
def properDivisors(n: BigInt): List[BigInt] = {
  val factors = factorize(n)
  val products = (1 until factors.length).flatMap(i => factors.combinations(i).map(_.product).toList).toList
  (BigInt(1) :: products).filter(_ < n)
}

val aliquotSum = properDivisors(n).sum

if (aliquotSum == BigInt("12142680281284711468101282998309016699980172"))
 println("Solution Found n == " + n)
