Short answer:
For N=50
[(0,49),(46,3)]

For the 100x100...
[(1,97),(8,2)]

Minimum N such that there's no solution. I wasn't able to find such an N but I verified that it's at least 160. Also, I conjecture it to be an even number, and linear extrapolation of the number of solutions from N from 6 to 32 makes it look like the minimum N would be 65, which isn't true. (see attached image).

Long answer:

Doing the naive iteration of choosing each subset of size two of a set of n^2 elements results in O(n^4) subsets. We can improve upon this by ordering the two Bs. That is, B1 must lie on the path from (0,0) if there are no Bs encountered. And B2 must be on the path from B1 excluding all the elements encountered before reaching B1.

We call the set of elements from (0,0) with no Bs "path0".

 def Path0(N: Int) = moveOrReturnFullPathIfStuck(N, State( Map(), (0,0), (0,-1)))

Call the subset of unique elements of path0 until B1, "path0minus". And call the unique elements starting from B1 that exclude elements of path0minus, "path1". B2 must be an element of that path.

So the solutions are generated by
def solutions(N: Int) =
 for {
  B1 <- Path0(N).distinctBy(_.robotPosition)
  B2 <- {
   val path1 = moveOrReturnFullPathIfStuck(N, State(B1.board.updated(B1.robotPosition, 3), B1.robotPosition,  B1.direction)).distinctBy(_.robotPosition)
   val path0minus = Path0(N).map(_.robotPosition).takeWhile( _ != B1.robotPosition).toSet
   path1.filterNot(x => path0minus.contains(x.robotPosition) )
  }
  if (doesSolve( State(B2.board.updated( B2.robotPosition, 3), B2.robotPosition, B2.direction), N)) 
 } yield (B1.robotPosition,B2.robotPosition)

This is a fairly good first crack at the problem, just needs some filling in to iterate through a run given 2 Bs. The tricky part is figuring out when you're stuck. My first stab at it was to have a running Set of all States encountered so far, and checking if the current state is in there.
A far more efficient solution was to realize that we can just keep track every time we encounter a dose==1 and turn. If we get to that position again without resetting, then we're in an infinite loop. However, there is a small bug in that we can be given a board with no dose==1s left, in which case we won't detect that we're in a loop.

Iterator.from(6).foreach{ N => println( N + " has " + solutions(N).size + " solutions") }
 
6 has 158 solutions
7 has 228 solutions
8 has 226 solutions
9 has 245 solutions
10 has 160 solutions
11 has 250 solutions
12 has 238 solutions
13 has 254 solutions
14 has 134 solutions
15 has 309 solutions
16 has 129 solutions
17 has 244 solutions
18 has 157 solutions
19 has 272 solutions
20 has 151 solutions
21 has 247 solutions
22 has 140 solutions
23 has 244 solutions
24 has 131 solutions
25 has 254 solutions
26 has 153 solutions
27 has 216 solutions
28 has 144 solutions
29 has 242 solutions
30 has 96 solutions
31 has 205 solutions
32 has 95 solutions
33 has 206 solutions
...

Iterator.from(83,4).find{ N => {
  println("N = " + N)
  solutions(N) match {
   case LazyList() =>
   {
    println("No Solution for N = " + N)
    true
   }
   case h #:: _ =>
   {
    println("Solution " + h)
    false
   }
  }
 }
 
This starts at N=83 and iterates to 87, 91 ..., I recompiled and with N=84, 85, and 86, and ran 4 in parallel to find a single solution for each N all the way up to 160. No idea how many solutions for those cases though.

I did one more refactor, which was to realize that path0minus and lots of path1 are identical for a large portion of the run (up until they wrap around the torus). And we can use run-length encoding to "warp" across a series of 2s. This involved reindexing from -N/2 to +N/2 instead of 0 to N-1, so the boards can be reused for larger Ns. This way I was able to run a batch of Ns, but it turned out not to yield any results.

By the end of this, seeing as there are no **s on the webpage, I'm guessing the minimal N is very high, and that we might need to use math to find it. I'm wondering if it doesn't exist. The number of combinations of B pairs grows as O(n^4) and yet there are only n rows and n columns (2n ways) for it to get stuck. So it wouldn't surprise me that the number of solutions grows with n.

This was a fun one, and I got to make a fun little movie while debugging. I've attached a frame of it, shows the chaos of it, indicating that there's no room to cheat and skip ahead to know if there's a solution or not.

Thanks again, looking forward to seeing if anyone got the minimum N.

Chris Shannon
(from Calgary, Canada)

