/*
Short Answer:
5, 5, 1, 1, 1
4, 2, 2, 2, 2, 1

Long Answer:

My first crack at this problem was to find the "trivial" solution, which is N=2, with all the column sums=1 and the row sums = [M-1, 1].  There are M matrices with these sums, where the second row has its element in each of the M columns.  Since if a row sum or column sum = 0 or if the row is full of 1s, then that row or column could be deleted.  This shows that non-trivial solutions must have N,M >= 3.

The hamming weight of the matrix need only be considered up to half the matrix.  Flipping all 0s and 1s would lead to mirror solutions.

An inefficient way to solve this problem is to iterate through all the matrices and increment a count for whatever their row sums and column sums end up being.  This would involve up to 2^50 iterations.

A better way is to start with guessing the size of the matrix and the hamming weight and counting the number of matrices.  We can cache previous results easily to make a fairly efficient algorithm.  My Scala codes runs in about 10 seconds and generates all non-trivial solutions.  Remaining solutions can be generated by flipping all the bits, or adding full or empty rows or columns anywhere.

The outline of my algorithm is as follows:

Iterate through the allowed number of rows N, number of columns M, and the Hamming weight of the matrix (ham).

for {
 N <- (3 to Math.floor(Math.sqrt(50)).toInt)
 M <- (N to 50/N)
 ham <-(Math.max(N,M) to N*M/2)
}

Iterate through all allowed row sums and col sums. Count all matrices satisfying the (row sum, col sum) pair.  If there are 29, we have a solution so print it.
(
for {
   rowSums <- listsLengthNThatSumToHam(N,ham, Math.min(ham -N+1, M-1))
   colSums <- listsLengthNThatSumToHam(M,ham, Math.min(ham -M+1, N-1))
   if (sumChildren(rowSums, colSums) == 29 )
 }
 yield {(rowSums,colSums)}) foreach println


The row sums and col sums must each sum to ham.  Each element of row sums and col sums must be > 0, and < M and N respectively, since we aren't going to bother considering empty or full rows or columns.  An empty or full row could be added without changing the count.  Therefore once a (row sum, col sum) pair has been found that counts to 29, infinitely more can be generated by adding full or empty rows or columns anywhere in the matrix.

The matrices satisfying these sums are counted by finding all rows that satisfy the first row sum and that does not go over the remaining col sums, and recursively adding all the matrices that satisfy the remaining row sums.  We drop the first row sum, and subtract off our candidate row from the col sums.
val children: List[Int] =
 for{
    c <- listsLengthNHammingWeightK(colSums.length, rowSums.head)
    if ((colSums zip c).forall(x => x._1 >= x._2)) }
     yield sumChildren(rowSums.tail, subList(colSums, c))
    children.sum

We can stop when we get to the last row.  Either it will be composed of only 1s or 0s, in which case the tree of candidates is a solution, or it won't.
if (rowSums.size == 1)
 if (colSums.forall(x => x == 1 || x == 0))
  1
 else
  0

The remaining detail is to generate the list of candidate rows.  The problem is to create a binary list of n items, with k of them being 1.  A recursive solution to this is that the first item is either 1 or 0 and we prepend to the solution to a subproblem.  If the first item is 1, the remaining n-1 items have k-1 1s.  If the first time is 0, the remaining n-1 items have k 1s.  If k==n, they are all 1, if k==0, they are all 0.
listsLengthNHammingWeightK(n-1,k-1).map(1 :: _) ::: listsLengthNHammingWeightK(n-1,k).map(0 :: _)

One last subproblem is to generate the list of row sums and col sums.  This problem reduces to finding all the sets of n positive integers that sum to a given constant h.  Again, recursion offers an elegant solution.  It's easiest to keep the list in descending order to avoid any duplicate work.  The first element (which is also the greatest number) must be at least h/n, but at most h-n+1 (note that when n=1, our (inclusive) range is from h to h).  Since the array is sorted in descending order, each of the following elements can be at most equal to the first element.  The maximum sum contributed is therefore n times this element.  This gives the lower bound of the first element to be ceiling(h/n).  The upper bound is recognizing that the minimum contribution from the following elements is 1 each, or n-1.  The first element cannot be larger than h-(n-1).  It can also not be larger than any element preceeding it, but it suffices to make it not larger than the element directly preceeding it.  Given this range, we prepend this first element, x, to the list generated by recursively finding n-1 integers that sum to h minus the first element (h-x), where the maximum value of any element is x or remaining h target, whichever is smaller.  We stop when we get to 0 elements.  Because of the careful choice of range, the 0 elements end up adding to h=0 as expected.

((Math.ceil(ham.floatValue/N).toInt to Math.min(nMax, ham -N+1)).flatMap(
    x => listsLengthNThatSumToHam(N-1, ham - x, x).map(List(x) ::: _) )).toList

One gotcha, that slipped through my first crack at this, is that the maximum row sum must be less than or equal to the number of columns.  There can be at most n 1s in an n length binary array.  Another gotcha is the funky syntax of Scala to get this all done.  range flatMap applying the recursion followed by a map to do the prepending followed by toList... yikes!

Since I used immutable data structures and purely functional code, there are no side effects when counting the candidate matrices.  I am therefore able to cache the results of previous sub matrices, avoiding exponential run time.  Also, since the number of matrices satisfying a (row sum, col sum) pair is not affected by swapping rows or swapping columns, we can sort the row sums and col sums to consolidate equivalent entries in the cache.  Side-effect-free code could be run in a distributed environment too, which is pretty nifty.

Thanks for another fun programming challenge, and Merry Christmas IBM!

Chris Shannon
Calgary, Canada
*/
/**********************/
// Scala code to solve IBM's December 2014 Ponder This.
object ponder {

def listsLengthNHammingWeightK(n: Int, k: Int): List[List[Int]] = (n-k,k) match {
 case (0,_) => List(List.fill(n){1})
 case (_,0) => List(List.fill(n){0})
 case _ =>  listsLengthNHammingWeightK(n-1,k-1).map(1 :: _) ::: listsLengthNHammingWeightK(n-1,k).map(0 :: _)
}                                                 //> listsLengthNHammingWeightK: (n: Int, k: Int)List[List[Int]]

listsLengthNHammingWeightK(5,3)                   //> res0: List[List[Int]] = List(List(1, 1, 1, 0, 0), List(1, 1, 0, 1, 0), List
                                                  //| (1, 1, 0, 0, 1), List(1, 0, 1, 1, 0), List(1, 0, 1, 0, 1), List(1, 0, 0, 1,
                                                  //|  1), List(0, 1, 1, 1, 0), List(0, 1, 1, 0, 1), List(0, 1, 0, 1, 1), List(0,
                                                  //|  0, 1, 1, 1))
 
 //Subtract two lists element by element
 def subList(a: List[Int], b: List[Int]): List[Int] =
 {
  (a zip b) map (x=> x._1 - x._2)
 }                                                //> subList: (a: List[Int], b: List[Int])List[Int]
def listsLengthNThatSumToHam(N: Int, ham: Int, nMax: Int): List[List[Int]] =  (N,ham) match
{
	case (0,_) => List(Nil)
  case _ => ((Math.ceil(ham.floatValue/N).toInt to Math.min(nMax, ham -N+1)).flatMap(
    x => listsLengthNThatSumToHam(N-1, ham - x, x).map(List(x) ::: _) )).toList
}                                                 //> listsLengthNThatSumToHam: (N: Int, ham: Int, nMax: Int)List[List[Int]]

listsLengthNThatSumToHam(3,10,8)                  //> res1: List[List[Int]] = List(List(4, 3, 3), List(4, 4, 2), List(5, 3, 2), L
                                                  //| ist(5, 4, 1), List(6, 2, 2), List(6, 3, 1), List(7, 2, 1), List(8, 1, 1))
val cache = collection.mutable.Map[ (List[Int], List[Int]), Int]()
                                                  //> cache  : scala.collection.mutable.Map[(List[Int], List[Int]),Int] = Map()
def sumChildren(rowSums: List[Int], colSums: List[Int]) : Int = {
  if (rowSums.size == 1)
   if (colSums.forall(x => x == 1 || x == 0))
    1
   else
    0
  else
  {
  // Using memoization here to increase the running time from exponential to quadratic or something
   cache.getOrElseUpdate( (rowSums.sortWith(_ >_),colSums.sortWith(_ > _)), {
   val children: List[Int] =
   for{
    // c is a candidate row that has the correct hamming weight by construction.
    // It is checked to make sure it does not exceed the target col sums.
    // If so, we recurse on the remaining rows and the reduces col sums.
    c <- listsLengthNHammingWeightK(colSums.length, rowSums.head)
    if ((colSums zip c).forall(x => x._1 >= x._2)) }
     yield sumChildren(rowSums.tail, subList(colSums, c))
    children.sum
   }
  )
 }
}                                                 //> sumChildren: (rowSums: List[Int], colSums: List[Int])Int
sumChildren(List(1,1,1),List(1,1,1))              //> res2: Int = 6

for {
 		N <- (3 to Math.floor(Math.sqrt(50)).toInt)  // N rows
 	  M <- (N to 50/N)                             // M columns
  	ham <-(Math.max(N,M) to N*M/2)               // Each row and column must have at least one 1.
                                                 // Can do 1-Matrix to get hamming weight greater than half the elements
  }
{
/* System.out.println(N)
 System.out.println(M)
 System.out.println(ham)
 */
 // Now create rowSums and colSums that sum to ham
 (
 for {
    // The M is not a typo.  The maximum value in a rowSum must be less than or equal to number of columns
    // The M-1 is because it's trivial to add a full row
	  rowSums <- listsLengthNThatSumToHam(N,ham, Math.min(ham -N+1, M-1))
    colSums <- listsLengthNThatSumToHam(M,ham, Math.min(ham -M+1, N-1))
    if (sumChildren(rowSums, colSums) == 29)
    }
    yield {(rowSums,colSums)}) foreach println    //> (List(8, 4, 1),List(2, 2, 2, 2, 1, 1, 1, 1, 1))
                                                  //| (List(10, 2, 1),List(2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1))
                                                  //| (List(14, 1, 1),List(2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))
                                                  //| (List(5, 3, 2, 1),List(3, 3, 2, 1, 1, 1))
                                                  //| (List(4, 3, 3, 1, 1),List(4, 3, 3, 1, 1))
                                                  //| (List(5, 5, 1, 1, 1),List(4, 2, 2, 2, 2, 1))
                                                  //| (List(7, 1, 1, 1, 1),List(4, 1, 1, 1, 1, 1, 1, 1))|
}

}